// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
/*
 * Copyright (C) 2019 PHYTEC Messtechnik GmbH
 * Author: Stefan Riedmueller <s.riedmueller@phytec.de>
 * Author: Simon Stuerz <simon.stuerz@nymea.io>
 * Author: Paul Budich <p.budich@consolinno.de>
 * Author: Alexander Pietsch <a.pietsch@consolinno.de>
 * Author: Leonid Verhovskij <l.verhovskij@consolinno.de>
 */

/dts-v1/;
#include "imx6ull.dtsi"
#include "imx6ull-phytec-phycore-som.dtsi"
#include "imx6ull-phytec-segin.dtsi"
#include "imx6ull-phytec-segin-peb-av-02.dtsi"
#include "imx6ull-phytec-segin-peb-eval-01.dtsi"

/ {
	model = "PHYTEC phyBOARD-Segin i.MX6 ULL Full Featured with eMMC";
	compatible = "phytec,imx6ull-pbacd10-emmc", "phytec,imx6ull-pbacd10",
		     "phytec,imx6ull-pcl063","fsl,imx6ull";

	memory {
		device_type = "memory";
		reg = <0x80000000 0x20000000>;
	};

	aliases {
		mmc0 = &usdhc1; /* uSD / MMC  */
		mmc1 = &usdhc2; /* internal eMMC */
	};
};


&adc1 {
	status = "okay";
};

&can1 {
	status = "okay";
};

&ecspi1 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_ecspi1>;
	cs-gpios = <0>;
	status = "enabled";
	tpm@0 {
		compatible = "infineon,slb9670";
		spi-max-frequency = <10000000>;
		reg = <0>; //cs0
		status = "okay";
	};
};

&ethphy1 {
	status = "okay";
};

&ethphy2 {
	interrupt-parent = <&gpio4>;
	interrupts = <16 IRQ_TYPE_LEVEL_LOW>;
	status = "okay";
};

&fec1 {
	status = "okay";
};

&fec2 {
	status = "okay";
};

&i2c_rtc {

	pinctrl-0 = <&pinctrl_rtc_1>;
	interrupt-parent = <&gpio1>;
	status = "okay";
	
};

&reg_can1_en {
	status = "okay";
};

&reg_sound_1v8 {
	status = "okay";
};

&reg_sound_3v3 {
	status = "okay";
};

&sai2 {
	status = "okay";
};

&sound {
	status = "okay";
};

/* DEBUG Port */
&uart1 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_uart1>;
	uart-has-rtscts;
	status = "okay";
};

/* Zigbee/Bluetooth */
&uart2 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_uart2>;
	uart-has-rtscts;
	status = "okay";
};

/* RS232 on 16pin output header */
&uart3 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_uart3>;
	status = "okay";
};

/* RS485-2 on RJ45 */
&uart4 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_uart4>;
	status = "okay";
};

/* wMbus */
&uart5 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_uart5>;
	status = "okay";
};

/* wMbRS485-1 on 16pin output header */
&uart6 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_uart6>;
	status = "okay";
};



&usbotg1 {
	status = "okay";
};

&usbotg2 {
	status = "okay";
};

&usdhc2 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_usdhc2>;
	bus-width = <8>;
	no-1-8-v;
	non-removable;
	keep-power-in-suspend;
	status = "okay";
};

&i2c1 {

	eepromnfc@53 {
		compatible = "st25dv,st25dv04k";
		reg = <0x53>;
		status = "disabled";
	};

	conegx@48 {
		pinctrl-0 = <&pinctrl_msp>;
		compatible = "consolinno,conegx";
		reg = <0x48>; /* I2C Adress */
		gpio-controller;
		#gpio-cells = <2>;

		/*
		pinctrl-names = "default";
		pinctrl-0 = <&conegx_pins>;
		*/
		
		interrupt-controller;
		#interrupt-cells = <2>;
		
		interrupt-parent = <&gpio3>;
		interrupts = <3 0x1>; // Pin Type(1=Rising)
		
	};



};


&can1 {                                                                           
        pinctrl-names = "default";                                                
        pinctrl-0 = <&pinctrl_flexcan1>;                                          
		status = "okay";                                                      
};

&usbotg1 {                                                                       
        pinctrl-names = "default";                                               
        pinctrl-0 = <&pinctrl_usb_otg1_id>;                                      
        dr_mode = "otg";                                                         
        status = "okay";                                                     
};  

&usbotg2 {                  
		pinctrl-names = "default";                                               
        pinctrl-0 = <&pinctrl_usb_otg2_id>;                                                  
        dr_mode = "host";                                                        
        disable-over-current;                                                    
        status = "okay";                                                     
};

&iomuxc {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_hog>;
 
 
	pinctrl_hog: hoggrp {
		fsl,pins = <
			MX6UL_PAD_CSI_VSYNC__GPIO4_IO19		0x10b0
			MX6UL_PAD_CSI_HSYNC__GPIO4_IO20		0x10b0 
			MX6UL_PAD_SD1_CLK__GPIO2_IO17		0x10b0
			MX6UL_PAD_SD1_CMD__GPIO2_IO16		0x10b0
			MX6UL_PAD_SD1_DATA2__GPIO2_IO20		0x10b0
			MX6UL_PAD_LCD_VSYNC__GPIO3_IO03		0x10b0
			MX6UL_PAD_LCD_RESET__GPIO3_IO04		0x10b0
			MX6UL_PAD_LCD_RESET__GPIO3_IO04		0x10b0
			MX6UL_PAD_UART5_TX_DATA__GPIO1_IO30		0x10b0
		
		>;
	};

	pinctrl_msp: mspgrp {
		fsl,pins = <
			MX6UL_PAD_LCD_VSYNC__GPIO3_IO03	0x110a0
		>;
	};
	
	pinctrl_uart1: uart1grp {
		fsl,pins = <
			MX6UL_PAD_UART1_TX_DATA__UART1_DCE_TX	0x1b0b1
			MX6UL_PAD_UART1_RX_DATA__UART1_DCE_RX	0x1b0b1
			MX6ULL_PAD_UART1_CTS_B__UART5_DCE_CTS	0x1b0b1
			MX6ULL_PAD_UART1_RTS_B__UART5_DCE_RTS	0x1b0b1
		>;
	};

	pinctrl_uart2: uart2grp {
		fsl,pins = <
			MX6UL_PAD_UART2_TX_DATA__UART2_DCE_TX	0x1b0b1
			MX6UL_PAD_UART2_RX_DATA__UART2_DCE_RX	0x1b0b1
			MX6UL_PAD_UART2_CTS_B__UART2_DCE_CTS	0x1b0b1
			MX6UL_PAD_UART2_RTS_B__UART2_DCE_RTS	0x1b0b1
		>;
	};

	pinctrl_uart3: uart3grp {
		fsl,pins = <
			MX6UL_PAD_UART3_TX_DATA__UART3_DCE_TX	0x1b0b1
			MX6UL_PAD_UART3_RX_DATA__UART3_DCE_RX	0x1b0b1
		>;
	};

	pinctrl_uart4: uart4grp {
		fsl,pins = <
			MX6UL_PAD_LCD_ENABLE__UART4_DCE_RX		0x1b0b1
			MX6UL_PAD_LCD_CLK__UART4_DCE_TX			0x1b0b1
		>;
	};

	pinctrl_uart5: uart5grp {
		fsl,pins = <
			MX6UL_PAD_GPIO1_IO04__UART5_DCE_TX		0x1b0b1
			MX6UL_PAD_GPIO1_IO05__UART5_DCE_RX		0x1b0b1
		>;
	};

	pinctrl_uart6: uart6grp {
		fsl,pins = <
			MX6UL_PAD_CSI_PIXCLK__UART6_DCE_RX		0x1b0b1
			MX6UL_PAD_CSI_MCLK__UART6_DCE_TX		0x1b0b1
		>;
	};

	pinctrl_ecspi1: ecspi1-grp {
		fsl,pins = <
			MX6UL_PAD_CSI_DATA07__ECSPI1_MISO	0x100b1
			MX6UL_PAD_CSI_DATA06__ECSPI1_MOSI	0x100b1
			MX6UL_PAD_CSI_DATA04__ECSPI1_SCLK	0x100b1
			MX6UL_PAD_CSI_DATA05__ECSPI1_SS0	0x1b0b0 	/* SS0 */
		>;
	};

	pinctrl_flexcan1: flexcan1 {                                             
		fsl,pins = <                                                     
			MX6UL_PAD_SD1_DATA0__FLEXCAN1_TX     0x0b0b0          
			MX6UL_PAD_SD1_DATA1__FLEXCAN1_RX     0x0b0b0          
		>;                                                               
        }; 
 
	pinctrl_usb_otg1_id: usbotg1idgrp {                                      
			fsl,pins = <                                                     
					MX6UL_PAD_GPIO1_IO00__ANATOP_OTG1_ID    0x17059          
			>;                                                               
	};
	pinctrl_usb_otg2_id: usbotg2idgrp {
		fsl,pins = <
			MX6UL_PAD_SD1_DATA3__ANATOP_OTG2_ID	0x17059
		>;
	};

	pinctrl_enet2: enet2grp {
		fsl,pins = <
			MX6UL_PAD_ENET2_RX_EN__ENET2_RX_EN	0x1b0b0
			MX6UL_PAD_ENET2_RX_ER__ENET2_RX_ER	0x1b0b0
			MX6UL_PAD_ENET2_RX_DATA0__ENET2_RDATA00	0x1b0b0
			MX6UL_PAD_ENET2_RX_DATA1__ENET2_RDATA01	0x1b0b0
			MX6UL_PAD_ENET2_TX_EN__ENET2_TX_EN	0x1b010
			MX6UL_PAD_ENET2_TX_DATA0__ENET2_TDATA00	0x1b010
			MX6UL_PAD_ENET2_TX_DATA1__ENET2_TDATA01	0x1b010
			MX6UL_PAD_ENET2_TX_CLK__ENET2_REF_CLK2	0x4001b010
			/* INT# */
			MX6UL_PAD_NAND_DQS__GPIO4_IO16		0x1b0b0
		>;
	};

	pinctrl_rtc_1: rtc1intgrp {
		fsl,pins = <
			MX6UL_PAD_UART5_RX_DATA__GPIO1_IO31	0x17059
		>;
	};
};
